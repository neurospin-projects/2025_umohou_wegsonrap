#!/usr/bin/env python3
# ns-app-getadproxy 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://documentation.dnanexus.com/developer for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import re
import subprocess
import glob

import dxpy
import numpy as np
import pandas as pd



def _get_admin_info():
    """ Automatically discover project_id dispensed dataset ID and load the dataset
    """
    dx_project_context_id  = os.environ.get("DX_PROJECT_CONTEXT_ID")
    print(f'DX_PROJECT_CONTEXT_ID is: [{dx_project_context_id}]')
    dispensed_dataset_id = dxpy.find_one_data_object(typename='Dataset', 
                                    name='app*.dataset',
                                    folder='/',
                                    name_mode='glob', 
                                    project=dx_project_context_id)['id']
    dataset = (':').join([dx_project_context_id, dispensed_dataset_id])
    # Obtain the 3 files for the metadata from RAP Central
    cmd = ["dx", "extract_dataset", dataset, "-ddd", "--delimiter", ","]
    subprocess.check_call(cmd)

    # keep tracks
    datadict_fnames = {}
    datadict_fnames["codings"] = glob.glob("*.codings.csv")[0]
    datadict_fnames["dictionary"] = glob.glob("*.data_dictionary.csv")[0]

    return dx_project_context_id, dataset, datadict_fnames

@dxpy.entry_point('main')
def main(tabexport_with_icd, outputprefix, output_folder):
    """
    Params:
    =======
        tabexport_with_icd : string the input file name from the RAP central
        outprefix : string to form the basename (name part of the final DXFile)
        output_folder : string to form the output_folder starting from the / of the projects
    Return:
    =======
        (implicit) : a dict with the entry outputfile that will contain a DXFile 
            description
    """
    # download the table
    # os.environ.get("DX_PROJECT_CONTEXT_ID")
    # !dx describe ":tmp/foret.csv"
    # tabexport_with_icd= ""
    tabexport_with_icd = dxpy.DXFile(tabexport_with_icd)
    dxpy.download_dxfile(tabexport_with_icd.get_id(), "tabexport_with_icd")

    # Read the csv file: basic extraction to elaborate the phenotype
    pd_pheno = pd.read_csv("tabexport_with_icd")

    # read the meta data to interpret this csv
    project_id, dataset, datadict_fnames = _get_admin_info()
    print(f'Fully qualified name of dataset record used: {dataset}')
    codings_df = pd.read_csv(datadict_fnames["codings"])

    # Collapse ICD-10 codes for Alzheimer's disease (G30* and F00*)
    ad_icd_codes = list(
        codings_df[(codings_df["coding_name"] == "data_coding_19") & ((codings_df["parent_code"] == "G30") | (codings_df["parent_code"] == "F00"))]["code"])
    ad_icd_codes

    # Replace NaN with string None for p41270
    # Note: eval will return Nonetype for string "None"
    pd_pheno["p41270"] = pd_pheno["p41270"].replace(np.nan, "None")


    # Get each participant's hospital inpatient records in ICD10 Diagnoses
    def icd10_codes(row):
        icd10_codes = row['p41270'] or []
        return list( set(icd10_codes) )

    pd_pheno['icd10_codes'] = pd_pheno.apply(icd10_codes, axis=1)

    # If the participant has any of the ICD-10 codes for AD, record the risk to "2" 
    def has_ad_icd10(row): 
        return 0 if set(row['icd10_codes']).isdisjoint(ad_icd_codes) else 2 
    pd_pheno['has_ad_icd10'] = pd_pheno.apply(has_ad_icd10, axis=1) 
    # Fix coding
    def fix_format_for_app_envir(block_ascendant):
        d = {}
        for i,row in block_ascendant.iterrows():
            for k in block_ascendant:
                if not isinstance(row[k], list):
                    continue
                else:
                    d.setdefault(i,[]).extend(row[k])
        retblock = dict((k,list(set(v))) for k, v in d.items())
        return retblock

    pd_pheno[pd_pheno.filter(regex='p20107*').columns]=pd_pheno.filter(regex='p20107*').map(lambda x: [int(i) for i in x.split('|')] if pd.notnull(x) else np.nan)
    pd_pheno['illnesses_of_father'] = fix_format_for_app_envir(pd_pheno.filter(regex='p20107*'))
    pd_pheno['illnesses_of_father'] = pd_pheno['illnesses_of_father'].apply(lambda x: [] if x is None or (isinstance(x, float) and pd.isna(x)) else x)
    pd_pheno[pd_pheno.filter(regex='p20110*').columns]=pd_pheno.filter(regex='p20110*').map(lambda x: [int(i) for i in x.split('|')] if pd.notnull(x) else np.nan)
    pd_pheno['illnesses_of_mother'] = fix_format_for_app_envir(pd_pheno.filter(regex='p20110*'))
    pd_pheno['illnesses_of_mother'] = pd_pheno['illnesses_of_mother'].apply(lambda x: [] if x is None or (isinstance(x, float) and pd.isna(x)) else x)

    # pd_pheno[pd_pheno.filter(regex='p20107*').columns]=pd_pheno.filter(regex='p20107*').map(lambda x: x.split('|') if pd.notnull(x) else np.nan)
    # pd_pheno[pd_pheno.filter(regex='p20110*').columns]=pd_pheno.filter(regex='p20110*').map(lambda x: [int(i) for i in x.split('|')] if pd.notnull(x) else np.nan)

    # pd_pheno['illnesses_of_father'] = pd_pheno.filter(regex=('p20107*')).apply(lambda x:  sum([i for i in x.tolist() if i is not None], []), axis=1)
    # pd_pheno['illnesses_of_mother'] = pd_pheno.filter(regex=('p20110*')).apply(lambda x:  sum([i for i in x.tolist() if i is not None], []), axis=1)

    # Get the max age between age at death and recorded age
    pd_pheno['father_age'] = pd_pheno.filter(regex=(r'(p1807_*|p2946_*)')).max(axis=1)
    pd_pheno['mother_age'] = pd_pheno.filter(regex=(r'(p3526_*|p1845_*)')).max(axis=1)

    # If the parent has diagnosed with AD (code 10), record it as 1; 
    # else assign parent's AD risk with their risk, which is their age (proportional to diff of age of 100) with minimum risk at 0.32 
    def parents_ad_risk(row): 
        import numpy as np 

        father_ad_risk = 1 if 10 in row['illnesses_of_father'] else np.maximum(0.32, (100 - row['father_age'])/100)
        mother_ad_risk = 1 if 10 in row['illnesses_of_mother'] else np.maximum(0.32, (100 - row['mother_age'])/100)
        return father_ad_risk + mother_ad_risk 
    # def parents_ad_risk(row):
    #     status = row['illnesses_of_father']
    #     father_ad_risk = np.maximum(0.32, (100 - row['father_age'])/100)
    #     if isinstance(status, list):
    #         if 10 in row['illnesses_of_father']:
    #             father_ad_risk = 1
    #     status = row['illnesses_of_mother']
    #     mother_ad_risk = np.maximum(0.32, (100 - row['mother_age'])/100)
    #     if isinstance(status, list):
    #         if 10 in row['illnesses_of_mother']:
    #             mother_ad_risk = 1
    #     return father_ad_risk + mother_ad_risk 

    pd_pheno['parents_ad_risk'] = pd_pheno.apply(parents_ad_risk, axis=1) 
    pd_pheno['ad_risk_by_proxy'] = pd_pheno[['has_ad_icd10','parents_ad_risk']].max(axis=1) 
    #pd_pheno[['ad_risk_by_proxy','parents_ad_risk','has_ad_icd10']].head() 

    # QC
    pd_pheno_qced = pd_pheno[
            (pd_pheno['p31'] == pd_pheno['p22001']) & # Filter in sex and genetic sex are the same
            (pd_pheno['p22006']==1) &            # in_white_british_ancestry_subset
            (pd_pheno['p22019'].isnull()) &      # Not Sex chromosome aneuploidy
            (pd_pheno['p22021']!=10) &           # Not Ten or more third-degree relatives identified (not 'excess_relatives')
            (pd_pheno['p22027'].isnull()) &      # Not het_missing_outliers
            ((pd_pheno['father_age'].notnull()) & (pd_pheno['father_age']>0)) &  # There is father's age
            ((pd_pheno['mother_age'].notnull()) & (pd_pheno['mother_age']>0)) &  # There is mother's age
            (pd_pheno['illnesses_of_father'].apply(lambda x:(-11 not in x and -13 not in x))) &  # Filter out "do not know" or "prefer not to answer" father illness
            (pd_pheno['illnesses_of_mother'].apply(lambda x:(-11 not in x and -13 not in x)))    # Filter out "do not know" or "prefer not to answer" mother illness
    ]
    # Visualize the distribution of the phenotype we derived
    # and save it
    ax = pd_pheno_qced['ad_risk_by_proxy'].hist(bins=30)
    fig = ax.get_figure()
    local_histo_outfname = f'histo_{outputprefix}.png'
    fig.savefig(local_histo_outfname)

    # All participants have ad_risk_by_proxy are considered cases (1) and the rest are considered as controls (0)

    pd_pheno_qced['ad_by_proxy'] = np.where(pd_pheno_qced['ad_risk_by_proxy']>= 1, 1, 0)
    print(pd_pheno_qced['ad_by_proxy'].value_counts())

    # Rename columns for better human readability 
    
    pd_pheno_qced = pd_pheno_qced.rename(columns=lambda x: re.sub('p22009_a','pc',x)) 
    pd_pheno_qced = pd_pheno_qced.rename(columns={'eid':'IID', 'p31': 'sex', 'p21022': 'age', 'p22006': 'ethnic_group', 
        'p22019': 'sex_chromosome_aneuploidy', 
        'p22021': 'kinship_to_other_participants', 
        'p22027': 'outliers_for_heterozygosity_or_missing'})
    
    # Add FID column -- required input format for regenie 
    pd_pheno_qced['FID'] = pd_pheno_qced['IID'] 

    # Join list of parent's illness -- making it a single string format rather than list format 
    pd_pheno_qced['illnesses_of_father'] = pd_pheno_qced['illnesses_of_father'].apply(lambda x: [str(i) for i in x if i]).str.join(",").replace(r'^\s*$', np.nan, regex=True)
    pd_pheno_qced['illnesses_of_mother'] = pd_pheno_qced['illnesses_of_mother'].apply(lambda x: [str(i) for i in x if i]).str.join(",").replace(r'^\s*$', np.nan, regex=True)

    # Join list of ICD10 code -- making it a single string format rather than list format
    pd_pheno_qced['icd10_codes'] = pd_pheno_qced['icd10_codes'].apply(lambda x: 'NA' if x is None else ",".join([str(i) for i in x]))
    
    # Create a phenotype table from our QCed data 
    pd_pheno_phenotype = pd_pheno_qced[['FID', 'IID', 'sex', 'age', 
        'ad_by_proxy', 'ad_risk_by_proxy', 
        'icd10_codes', 'has_ad_icd10', 
        'ethnic_group', 'sex_chromosome_aneuploidy', 
        'kinship_to_other_participants', 
        'outliers_for_heterozygosity_or_missing', 
        'illnesses_of_father', 'illnesses_of_mother', 
        'father_age', 'mother_age', 'parents_ad_risk'] + [f'pc{i}' for i in range(1, 41)]]

    #save
    local_outfname = f'{outputprefix}.phe'
    pd_pheno_phenotype.to_csv(local_outfname, sep='\t', na_rep='NA', index=False, quoting=3 )

    remote_outDXFile = dxpy.upload_local_file(local_outfname, project=project_id, folder=output_folder)
    #no track on thisupload
    dxpy.upload_local_file(local_histo_outfname, project=project_id, folder=output_folder)

    output = {}
    output["output_pheno_file"] = dxpy.dxlink(remote_outDXFile)

    return output

dxpy.run()
